import { Response, Router } from 'express';
import { AuthenticatedRequest, authenticateUser } from '../middleware/auth.js';
import { TeamRole } from '../types/database.js';
import { requireTeamRole } from '../utils/roleAuth.js';
import { supabase } from '../utils/supabase.js';

const router = Router();

// Join code generation constants
const SAFE_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
const CODE_LENGTH = 4;
const MAX_ATTEMPTS = 100;

/**
 * Generates a unique join code by checking the team_join_codes table
 */
async function generateUniqueJoinCode(): Promise<string>
{
  for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++)
  {
    // Generate random code
    let code = '';
    for (let i = 0; i < CODE_LENGTH; i++)
    {
      code += SAFE_CHARS.charAt(Math.floor(Math.random() * SAFE_CHARS.length));
    }

    // Check if code exists in team_join_codes table
    const { data, error } = await supabase
      .from('team_join_codes')
      .select('id')
      .eq('code', code)
      .limit(1);

    if (error)
    {
      throw new Error(`Database error while checking join code uniqueness: ${error.message}`);
    }

    // If no matches found, code is unique
    if (!data || data.length === 0)
    {
      return code;
    }
  }

  throw new Error(`Failed to generate unique join code after ${MAX_ATTEMPTS} attempts`);
}

// All routes require authentication
router.use(authenticateUser);

// Create a new team
router.post('/', async (req: AuthenticatedRequest, res: Response): Promise<void> =>
{
  try
  {
    const { name } = req.body;
    const userId = req.user?.id;

    if (!name)
    {
      res.status(400).json({ error: 'Team name is required' });
      return;
    }

    // Create team (join code will be auto-generated by trigger)
    const { data: teamData, error: teamError } = await supabase
      .from('teams')
      .insert({
        name,
      })
      .select()
      .single();

    if (teamError)
    {
      res.status(400).json({ error: teamError.message });
      return;
    }

    // Add creator as coach
    const { error: membershipError } = await supabase
      .from('team_memberships')
      .insert({
        team_id: teamData.id,
        user_id: userId!,
        role: TeamRole.Coach,
      });

    if (membershipError)
    {
      res.status(400).json({ error: 'Failed to add user to team' });
      return;
    }

    // Get the auto-generated join code
    const { data: joinCodeData, error: joinCodeError } = await supabase
      .from('team_join_codes')
      .select('code')
      .eq('team_id', teamData.id)
      .eq('is_active', true)
      .single();

    res.status(201).json({
      message: 'Team created successfully',
      team: {
        ...teamData,
        join_code: joinCodeData?.code,
      },
    });
  }
  catch (error)
  {
    console.error('Create team error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user's teams
router.get('/', async (req: AuthenticatedRequest, res: Response): Promise<void> =>
{
  try
  {
    const userId = req.user?.id;

    if (!userId)
    {
      res.status(401).json({ error: 'User not authenticated' });
      return;
    }

    const { data: teams, error } = await supabase
      .from('team_memberships')
      .select(`
        role,
        teams (
          id,
          name,
          created_at
        )
      `)
      .eq('user_id', userId);

    if (error)
    {
      res.status(400).json({ error: error.message });
      return;
    }

    res.json(teams);
  }
  catch (error)
  {
    console.error('Get teams error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update team - require coach or admin role
router.put(
  '/:teamId',
  requireTeamRole([TeamRole.Coach, TeamRole.Admin]),
  async (req: AuthenticatedRequest, res: Response): Promise<void> =>
  {
    try
    {
      const { teamId } = req.params;
      const { name } = req.body;

      const { data: teamData, error: updateError } = await supabase
        .from('teams')
        .update({ name })
        .eq('id', teamId)
        .select()
        .single();

      if (updateError)
      {
        res.status(400).json({ error: updateError.message });
        return;
      }

      res.json({
        message: 'Team updated successfully',
        team: teamData,
      });
    }
    catch (error)
    {
      console.error('Update team error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  },
);

// Join team using join code
router.post('/join', async (req: AuthenticatedRequest, res: Response): Promise<void> =>
{
  try
  {
    const { joinCode, selectedRole } = req.body;
    const userId = req.user?.id;

    if (!userId)
    {
      res.status(401).json({ error: 'User not authenticated' });
      return;
    }

    if (!joinCode)
    {
      res.status(400).json({ error: 'Join code is required' });
      return;
    }

    // Find active join code
    const { data: joinCodeData, error: findError } = await supabase
      .from('team_join_codes')
      .select(`
        team_id,
        team_role,
        is_active,
        expires_at,
        teams!inner(id, name)
      `)
      .eq('code', joinCode)
      .eq('is_active', true)
      .single();

    if (findError || !joinCodeData)
    {
      res.status(404).json({ error: 'Invalid or inactive join code' });
      return;
    }

    // Check if code is expired
    if (joinCodeData.expires_at && new Date(joinCodeData.expires_at) < new Date())
    {
      res.status(400).json({ error: 'Join code has expired' });
      return;
    }

    // Determine the role
    let roleToAssign: TeamRole;

    if (joinCodeData.team_role)
    {
      // Role is fixed by the join code
      roleToAssign = joinCodeData.team_role as TeamRole;
    }
    else if (selectedRole)
    {
      // User can select role
      if (!Object.values(TeamRole).includes(selectedRole as TeamRole))
      {
        res.status(400).json({ error: 'Invalid role selected' });
        return;
      }
      roleToAssign = selectedRole as TeamRole;
    }
    else
    {
      res.status(400).json({ error: 'Role selection is required for this join code' });
      return;
    }

    // Check if user is already a member of this team
    const { data: existingMembership, error: membershipCheckError } = await supabase
      .from('team_memberships')
      .select('id, role')
      .eq('team_id', joinCodeData.team_id)
      .eq('user_id', userId)
      .single();

    if (membershipCheckError && membershipCheckError.code !== 'PGRST116')
    { // PGRST116 = no rows found
      res.status(400).json({ error: membershipCheckError.message });
      return;
    }

    if (existingMembership)
    {
      res.status(409).json({
        error: `You are already a member of this team as a ${existingMembership.role}`,
      });
      return;
    }

    // Get user's profile for potential player name
    let userProfile = null;
    if (roleToAssign === TeamRole.Player)
    {
      const { data: profile, error: profileError } = await supabase
        .from('user_profiles')
        .select('name')
        .eq('id', userId)
        .single();

      if (!profileError && profile)
      {
        userProfile = profile;
      }
    }

    // Perform database operations with error handling for rollback
    let membershipCreated = false;
    let playerProfileId = null;

    try
    {
      // Add user to team with the determined role
      const { error: joinError } = await supabase
        .from('team_memberships')
        .insert({
          team_id: joinCodeData.team_id,
          user_id: userId!,
          role: roleToAssign,
        });

      if (joinError)
      {
        res.status(400).json({ error: 'Failed to join team' });
        return;
      }

      membershipCreated = true;

      // If user is joining as a player, create player profile
      if (roleToAssign === TeamRole.Player)
      {
        const { playerName, jerseyNumber } = req.body;

        // Use provided playerName or fall back to user's name
        const finalPlayerName = playerName || userProfile?.name;

        const { data: playerProfile, error: playerError } = await supabase
          .from('player_profiles')
          .insert({
            name: finalPlayerName,
            jersey_number: jerseyNumber || null,
            user_id: userId,
          })
          .select()
          .single();

        if (playerError)
        {
          // Rollback membership creation
          await supabase
            .from('team_memberships')
            .delete()
            .eq('team_id', joinCodeData.team_id)
            .eq('user_id', userId!);

          res.status(400).json({ error: 'Failed to create player profile' });
          return;
        }

        playerProfileId = playerProfile.id;

        // Link player to team
        const { error: linkError } = await supabase
          .from('team_players')
          .insert({
            team_id: joinCodeData.team_id,
            player_id: playerProfile.id,
          });

        if (linkError)
        {
          // Rollback both membership and player profile creation
          await supabase
            .from('player_profiles')
            .delete()
            .eq('id', playerProfile.id);

          await supabase
            .from('team_memberships')
            .delete()
            .eq('team_id', joinCodeData.team_id)
            .eq('user_id', userId!);

          res.status(400).json({ error: 'Failed to link player to team' });
          return;
        }
      }
    }
    catch (error)
    {
      // Cleanup on unexpected error
      if (playerProfileId)
      {
        await supabase
          .from('player_profiles')
          .delete()
          .eq('id', playerProfileId);
      }

      if (membershipCreated)
      {
        await supabase
          .from('team_memberships')
          .delete()
          .eq('team_id', joinCodeData.team_id)
          .eq('user_id', userId!);
      }

      throw error;
    }

    const teamInfo = Array.isArray(joinCodeData.teams) ? joinCodeData.teams[0] : joinCodeData.teams;

    res.status(200).json({
      message: `Successfully joined team "${teamInfo.name}" as ${roleToAssign}`,
      team: {
        id: joinCodeData.team_id,
        name: teamInfo.name,
        role: roleToAssign,
      },
    });
  }
  catch (error)
  {
    console.error('Join team error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create additional join code for a team
router.post(
  '/:teamId/join-codes',
  requireTeamRole([TeamRole.Coach, TeamRole.Admin, TeamRole.Guardian]),
  async (req: AuthenticatedRequest, res: Response): Promise<void> =>
  {
    try
    {
      const { teamId } = req.params;
      const { team_role, expires_at, guardian } = req.body;
      const userId = req.user?.id;

      if (!userId)
      {
        res.status(401).json({ error: 'User not authenticated' });
        return;
      }

      // Get the current user's role on this team
      const { data: userMembership, error: membershipError } = await supabase
        .from('team_memberships')
        .select('role')
        .eq('team_id', teamId)
        .eq('user_id', userId)
        .single();

      if (membershipError || !userMembership)
      {
        res.status(403).json({ error: 'User is not a member of this team' });
        return;
      }

      const userRole = userMembership.role as TeamRole;

      // If the user creating the join code is a guardian, apply strict restrictions
      if (userRole === TeamRole.Guardian)
      {
        // guardians must specify a team_role
        if (!team_role)
        {
          res.status(400).json({ 
            error: 'guardians must specify a team_role when creating join codes' 
          });
          return;
        }

        // guardians can only create join codes for player or guardian roles
        if (![TeamRole.Player, TeamRole.Guardian].includes(team_role as TeamRole))
        {
          res.status(400).json({ 
            error: 'guardians can only create join codes for "player" or "guardian" roles' 
          });
          return;
        }
      }
      else
      {
        // Validate team_role if provided (normal validation for non-guardian codes)
        if (team_role && !Object.values(TeamRole).includes(team_role as TeamRole))
        {
          res.status(400).json({ error: 'Invalid team role' });
          return;
        }
      }

      // Generate unique join code
      const code = await generateUniqueJoinCode();

      // Create join code
      const { data: joinCodeData, error: createError } = await supabase
        .from('team_join_codes')
        .insert({
          team_id: teamId,
          code,
          created_by: userId!,
          team_role: team_role || null,
          expires_at: expires_at || null,
          is_active: true,
        })
        .select()
        .single();

      if (createError)
      {
        res.status(400).json({ error: createError.message });
        return;
      }

      res.status(201).json({
        message: 'Join code created successfully',
        join_code: joinCodeData,
      });
    }
    catch (error)
    {
      console.error('Create join code error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  },
);

// Get labels for a team
router.get(
  '/:teamId/labels',
  requireTeamRole([TeamRole.Coach, TeamRole.Admin, TeamRole.Player, TeamRole.Guardian]),
  async (req: AuthenticatedRequest, res: Response): Promise<void> =>
  {
    try
    {
      const { teamId } = req.params;

      const { data: labels, error } = await supabase
        .from('labels')
        .select('*')
        .eq('team_id', teamId)
        .order('name');

      if (error)
      {
        res.status(400).json({ error: error.message });
        return;
      }

      res.json(labels || []);
    }
    catch (error)
    {
      console.error('Get team labels error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  },
);

// Create a label for a team
router.post(
  '/:teamId/labels',
  requireTeamRole([TeamRole.Coach, TeamRole.Admin]),
  async (req: AuthenticatedRequest, res: Response): Promise<void> =>
  {
    try
    {
      const { teamId } = req.params;
      const { name } = req.body;

      if (!name || !name.trim())
      {
        res.status(400).json({ error: 'Label name is required' });
        return;
      }

      const { data: label, error } = await supabase
        .from('labels')
        .insert({
          team_id: teamId,
          name: name.trim(),
        })
        .select()
        .single();

      if (error)
      {
        if (error.code === '23505') // Unique constraint violation
        {
          res.status(409).json({ error: 'Label with this name already exists for this team' });
          return;
        }
        res.status(400).json({ error: error.message });
        return;
      }

      res.status(201).json(label);
    }
    catch (error)
    {
      console.error('Create team label error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  },
);

// Get players for a team
router.get(
  '/:teamId/players',
  requireTeamRole([TeamRole.Coach, TeamRole.Admin, TeamRole.Player, TeamRole.Guardian]),
  async (req: AuthenticatedRequest, res: Response): Promise<void> =>
  {
    try
    {
      const { teamId } = req.params;

      const { data: players, error } = await supabase
        .from('team_players')
        .select(`
          player_profiles (
            id,
            name,
            jersey_number,
            user_id
          )
        `)
        .eq('team_id', teamId);

      if (error)
      {
        res.status(400).json({ error: error.message });
        return;
      }

      // Flatten the structure to make it easier to work with
      const flattenedPlayers = players?.map(tp => tp.player_profiles).filter(Boolean) || [];

      res.json(flattenedPlayers);
    }
    catch (error)
    {
      console.error('Get team players error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  },
);

export default router;
